///فكرة المسئلة  هديك  مثلا 50 جنية وقلك  بكام طريقة ممكن تفكها   وهديك العملات الى محتاجها ف الفك وكدة 
// ف المسئلة هنا  بيديك مضعفات الخمسة فلوك وعاوك تفكها ب11 قيمة هدهالك ف الارى   
// اول حاجة هحل الحل العادى  الميميز وبعد كدة هنطورة   

//O(COINS*rem * rem)
===================================================================
// دة الكود العادى هنشوف خطوات تحويلة ل
// table
const int COINS = 11;
const int MAXCONINTS = 30000 + 1;
int coins[] = { 5,10,20,50,100,200,500,1000,2000,5000,10000 };
ll mem[COINS][MAXCONINTS];
int func(int idx,int rem) {

    if (rem == 0)
        return 1;
    if (rem < coins[idx] || idx == COINS)
        return 0;

    ll& ret = mem[idx][rem];
    if (~ret)return ret;

    ret = func(idx + 1, rem);
    while (rem-coins[idx]>=0)
    {
        ret += func(idx , rem- coins[idx]);
        rem -= coins[idx];
    }
    return ret;
}

===================================================================
// اول خطوة انى  اعمل 
// push loop in pramters 
//يعنى اشوف اى  لوب جوة البادى  وخلية ف البرامترز 
//O(COINS*rem)
===================================================================


onst int COINS = 11;
const int MAXCONINTS = 30000 + 1;
int coins[] = { 5,10,20,50,100,200,500,1000,2000,5000,10000 };
ll mem[COINS][MAXCONINTS];
int func(int idx,int rem) {

    if (rem == 0)
        return 1;
    if (rem < coins[idx] || idx == COINS)
        return 0;

    ll& ret = mem[idx][rem];
    if (~ret)return ret;

    ret = func(idx + 1, rem)+ func(idx + 1, rem-coins[idx]);
    
    return ret;
}




===================================================================
// المرحلة الجاية هنحولة ل
//table 
// فكرة التابل بتعتمد على انك تبداء من  اقل مشكلة وتكبرها تانى  ولازم يكون  ف حل للمشكلة الصغيرة عشان تقدر تكبرها 
// اول حاجة هحاول اترجم الbase case  
//احولها   لسطر كود  لوب كدة 
//ف الاول كان معاية  رقم كبير  " فلوس الى عاوز افكها " وكنت بفضل انقص منه  شوية شوية  لحاد موصل لرقم انا انا عرف اجابتة  الى هو ارجع واحد  لما القيمة تبقا بصفر 
// ف الكود الى جاى عاوز  هبداء بقيمة انا عارف حلها الى هى ال base case 
//وفضل اكبر  اعتمادا على الى قبلى وكدة 


===================================================================
// شرح فكرة الكود  
// اول حاجة  ينفع تبدال الوب هنا   

O(COINS*rem)
===================================================================

const int COINS = 11;
const int MAXCONINTS = 30000 + 1;
int coins[] = { 5,10,20,50,100,200,500,1000,2000,5000,10000 };
ll mem[COINS][MAXCONINTS];
void func(int idx,int rem) {
    // دة بيكافئ 
     //  if (rem == 0)
       // return 1;
    for (int i = 0; i < COINS; i++) {  //like base case
        mem[i][0] = 1;
    }


    for (int coin= coins[0]; coin < MAXCONINTS; coin+=5) {

        for (int j = 0; j < COINS; j++) {

            if (j)
                mem[j][coin] = mem[j - 1][coin]; //  روح  شوف انا عمتها بكام قبل كدة  وهات القيمة عشان هزود عليها  يعنى مثلا لو هكون العشرة ف دة بيقلة روح شوف ونا دلوتى ف الخانة التالتة الى هى عاوز اشوف اقدر اكون العشرة ب عشرة ازاى 
                                                  // ف السطر دة هيروح يشوف انا كونت العشرة من الاول  خالص لحاد القيمة الى فوق الى انا واقف عندا بكام طريقة ويجبهالى  عشان هزود عليها 
            if (rem - coins[j] >= 0) {
                mem[j][coin] += mem[j ][rem-coins[j]];  //السطر دة بيطرح قيمة من العملات الى بفك بيها    من الفلوس الكلية  الى عاوز افكها  يعنى لو  عاوز اكون  ال15  ف هيطرح منها 5ويشوف عدد طرق تكوين 10الى هيلاقيها محسوبة    وبعد كدة يطرح 10 ويشوف قيمة ال 5 وطبعا هيلاقيها محسوبة وبكدة 
            }                                             //  ودى نفس الفكرة ف الكود العادى انى اطرح رقم" من الى بفك بية" وشف ازاى اقدر اكون الرقم الباقى والرقم الباقى اطرح منة برضو  لحاد موصل للصفر ورجع 1 وكدة حليت المشكلة باتجزء اما ف التابل ف انا ببداء بالصغير الاول وهكذا
        }
                                                          // يعنى بحسب الاصغر ثم الاكبر بحسبة بستخدام الاكبر  ف انا كونت الخمسة  وكونت العضرة بستخدام الخمسة وكدة 
    }
    // anser in last row 

}
===================================================================
فايدة  اخر كود اية طلام انا  برضو  اخت  
O(COINS*rem)
الفايدة لسة جاية ف  تركة اسمها  
roring technic
ف اخر كود لو لحظت هتلاقى    ان انا بستخدام اخر صفين عندى بس الى هو بكونة والى قبلية  فبدال مكان عندى  ارى فيها 11 صف وممكن يزيدة هخليهم صفين بس   
ينفع ان اعكس الاتنين لوب 

===================================================================


const int COINS = 11;
const int MAXCONINTS = 30000 + 1;
int coins[] = { 5,10,20,50,100,200,500,1000,2000,5000,10000 };
ll mem[2][MAXCONINTS];
void func(int idx,int rem) {

        int p = 0;
        mem[p][0] =mem[!p][0];
    

        // هنا هنا عند الى على  الاعمدة القيمة الى هتفكها والى على الصفوف القيمة الى بتفك بيها 
        // انت هتمشى  صف صف   كل مرة  او كل صف هتطرح منة قيمة  وحدة بس    الى هى قيمة   
      // حوار الmem[p][coin] =0
       // دة هتخلية بصفر اول مرة ادخل فية  وتانى مرة ادخل فية   او مرة ونا معنديش قيم وتانى مرة ونا عندى قيم بس خلاص عاوز امسحها  
        for (int j = 0; j < COINS; j++) {
            p = !p;

             for (int coin= coins[0]; coin < MAXCONINTS; coin+=5) {

                 mem[p][coin] = 0; // مش فاهم 
                if (j)
                  mem[j][coin] = mem[j - 1][coin];
            if (rem - coins[j] >= 0) {
                 mem[j][coin] += mem[j ][rem-coins[j]];
}
            
              }
        }
   
}


===================================================================
ف تركة تانى  ف  اخر الفديو انا مش كتبها هنا  للاسف عشان صعبة شوية 
===================================================================












